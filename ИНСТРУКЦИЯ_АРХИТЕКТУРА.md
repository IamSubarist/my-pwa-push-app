# Архитектура PWA Push-приложения

## Обзор системы

Это Progressive Web Application (PWA) с поддержкой push-уведомлений. Приложение состоит из трех основных компонентов:

1. **Фронтенд** (React + Vite) - пользовательский интерфейс
2. **Бэкенд** (FastAPI + Python) - серверная логика и API
3. **База данных** (Supabase/PostgreSQL) - хранение данных пользователей и подписок

---

## Компоненты системы

### 1. Фронтенд (React приложение)

**Расположение**: `src/App.jsx`

**Основные функции**:

- Авторизация пользователей (регистрация и вход)
- Управление подписками на push-уведомления
- Отправка тестовых уведомлений
- Установка PWA на устройство

**Ключевые технологии**:

- React - библиотека для создания пользовательского интерфейса
- Service Worker API - для работы с push-уведомлениями
- Web Push API - стандарт для отправки уведомлений
- LocalStorage - для хранения токена авторизации

### 2. Бэкенд (FastAPI сервер)

**Расположение**: `backend/main.py`

**Основные функции**:

- Регистрация и авторизация пользователей
- Управление подписками на push-уведомления
- Отправка push-уведомлений через Web Push API
- Хранение данных в базе данных

**Ключевые технологии**:

- FastAPI - современный веб-фреймворк для Python
- JWT (JSON Web Tokens) - для авторизации
- bcrypt - для хеширования паролей
- pywebpush - библиотека для отправки push-уведомлений
- VAPID - протокол для аутентификации push-сервисов

### 3. База данных (Supabase/PostgreSQL)

**Структура таблиц**:

**Таблица `users`**:

- `id` - уникальный идентификатор пользователя
- `username` - имя пользователя
- `email` - электронная почта (уникальная)
- `hashed_password` - хешированный пароль
- `created_at` - дата создания аккаунта

**Таблица `push_subscriptions`**:

- `id` - уникальный идентификатор подписки
- `endpoint` - URL для отправки уведомлений (уникальный)
- `p256dh` - публичный ключ для шифрования
- `auth` - секретный ключ для аутентификации
- `user_id` - связь с пользователем
- `created_at` - дата создания подписки

### 4. Service Worker

**Расположение**: `public/sw.js`

**Основные функции**:

- Кэширование ресурсов приложения
- Обработка входящих push-уведомлений
- Отображение уведомлений пользователю
- Обработка кликов по уведомлениям

---

## Как работает авторизация

### Регистрация нового пользователя

1. **Пользователь заполняет форму** (имя, email, пароль)
2. **Фронтенд отправляет данные** на `/api/register`
3. **Бэкенд проверяет**:
   - Существует ли пользователь с таким email
   - Валидность данных
4. **Бэкенд создает пользователя**:
   - Хеширует пароль с помощью bcrypt
   - Сохраняет данные в базу данных
   - Генерирует JWT токен (действителен 30 дней)
5. **Бэкенд возвращает токен** фронтенду
6. **Фронтенд сохраняет токен** в LocalStorage
7. **Пользователь автоматически авторизован**

### Вход существующего пользователя

1. **Пользователь вводит email и пароль**
2. **Фронтенд отправляет данные** на `/api/login`
3. **Бэкенд проверяет**:
   - Существует ли пользователь с таким email
   - Правильность пароля (сравнивает хеш)
4. **Если все верно**:
   - Генерирует новый JWT токен
   - Возвращает токен фронтенду
5. **Фронтенд сохраняет токен** и авторизует пользователя

### Проверка авторизации

При каждом запросе к защищенным эндпоинтам:

1. **Фронтенд отправляет токен** в заголовке `Authorization: Bearer <токен>`
2. **Бэкенд проверяет токен**:
   - Расшифровывает JWT
   - Проверяет срок действия
   - Извлекает ID пользователя
3. **Если токен валиден** - запрос выполняется
4. **Если токен невалиден** - возвращается ошибка 401

---

## Как работает подписка на push-уведомления

### Шаг 1: Запрос разрешения на уведомления

1. **Пользователь нажимает** кнопку "Включить уведомления"
2. **Браузер показывает диалог** с запросом разрешения
3. **Если пользователь разрешает**:
   - Разрешение сохраняется в браузере
   - Статус меняется на `granted`

### Шаг 2: Регистрация Service Worker

1. **Фронтенд проверяет** поддержку Service Worker API
2. **Регистрирует Service Worker** (`/sw.js`)
3. **Service Worker активируется** и начинает работать в фоне
4. **Service Worker работает** даже когда сайт закрыт

### Шаг 3: Получение VAPID публичного ключа

1. **Фронтенд запрашивает** публичный ключ с `/api/vapid-public-key`
2. **Бэкенд возвращает** публичный VAPID ключ
3. **VAPID ключ** используется для подписки на уведомления

**Что такое VAPID?**

- VAPID (Voluntary Application Server Identification) - протокол для идентификации сервера
- Позволяет серверу отправлять push-уведомления без использования сторонних сервисов
- Состоит из пары ключей: публичный (открытый) и приватный (секретный)

### Шаг 4: Создание подписки

1. **Фронтенд вызывает** `registration.pushManager.subscribe()`
2. **Браузер создает подписку** с помощью:
   - VAPID публичного ключа
   - Push-сервиса браузера (Chrome использует FCM, Firefox - свой сервис)
3. **Браузер возвращает объект подписки**:
   ```javascript
   {
     endpoint: "https://fcm.googleapis.com/...", // URL для отправки уведомлений
     keys: {
       p256dh: "...", // Публичный ключ для шифрования
       auth: "..."    // Секретный ключ для аутентификации
     }
   }
   ```

### Шаг 5: Сохранение подписки на сервере

1. **Фронтенд отправляет подписку** на `/api/subscribe` с токеном авторизации
2. **Бэкенд проверяет**:
   - Валидность токена (кто отправляет)
   - Наличие всех необходимых данных
3. **Бэкенд сохраняет подписку** в базу данных:
   - Связывает подписку с пользователем (`user_id`)
   - Сохраняет `endpoint`, `p256dh`, `auth`
4. **Теперь сервер знает**, куда отправлять уведомления этому пользователю

**Важно**: Один пользователь может иметь несколько подписок (например, на разных устройствах)

---

## Как отправляется push-уведомление

### Шаг 1: Инициация отправки

**Вариант А: Пользователь нажимает "Отправить тестовое уведомление"**

1. **Фронтенд отправляет запрос** на `/api/send-notification`
2. **В запросе указывается**:
   - Заголовок уведомления (`title`)
   - Текст уведомления (`body`)
   - Иконка (`icon`)
   - Токен авторизации (чтобы узнать, кто отправляет)

**Вариант Б: Автоматическая отправка (например, по расписанию)**

- Бэкенд может отправлять уведомления автоматически
- Например, по cron-задаче или при определенных событиях

### Шаг 2: Подготовка данных на бэкенде

1. **Бэкенд получает запрос** и проверяет токен авторизации
2. **Определяет пользователя** из токена
3. **Находит все подписки** этого пользователя в базе данных
4. **Подготавливает данные уведомления**:
   ```json
   {
     "title": "Тестовое уведомление",
     "body": "Это тестовое push-уведомление!",
     "icon": "/vite.svg",
     "badge": "/vite.svg",
     "tag": "default",
     "data": {}
   }
   ```

### Шаг 3: Отправка через Web Push API

Для каждой подписки пользователя:

1. **Бэкенд использует библиотеку `pywebpush`** для отправки
2. **Библиотека выполняет**:

   - Шифрует данные уведомления с помощью ключей подписки (`p256dh`, `auth`)
   - Подписывает запрос приватным VAPID ключом
   - Отправляет POST запрос на `endpoint` (например, `https://fcm.googleapis.com/...`)

3. **Push-сервис браузера** (FCM для Chrome, свой для Firefox):
   - Проверяет подпись VAPID
   - Проверяет валидность подписки
   - Если все в порядке - принимает уведомление

### Шаг 4: Доставка на устройство

1. **Push-сервис отправляет уведомление** на устройство пользователя
2. **Операционная система** получает уведомление
3. **Браузер активирует Service Worker** (даже если сайт закрыт)
4. **Service Worker получает событие `push`**

### Шаг 5: Обработка в Service Worker

1. **Service Worker получает событие** `push` с зашифрованными данными
2. **Расшифровывает данные** (используя сохраненные ключи)
3. **Извлекает информацию** о уведомлении (заголовок, текст, иконка)
4. **Показывает уведомление** пользователю через `self.registration.showNotification()`

### Шаг 6: Отображение уведомления

1. **Операционная система показывает** уведомление пользователю
2. **Пользователь видит**:
   - Заголовок
   - Текст
   - Иконку (если указана)
3. **Если пользователь кликает** на уведомление:
   - Service Worker получает событие `notificationclick`
   - Открывает или фокусирует окно приложения

---

## Схема потока данных

```
┌─────────────┐
│  Пользователь │
└──────┬───────┘
       │
       │ 1. Регистрация/Вход
       ▼
┌─────────────────┐
│   Фронтенд      │
│   (React)        │
└──────┬───────────┘
       │
       │ 2. Запрос VAPID ключа
       ▼
┌─────────────────┐         ┌──────────────┐
│   Бэкенд        │◄────────│  База данных │
│   (FastAPI)     │         │  (Supabase)  │
└──────┬──────────┘         └──────────────┘
       │
       │ 3. Возврат публичного ключа
       ▼
┌─────────────────┐
│   Фронтенд      │
│   (React)        │
└──────┬───────────┘
       │
       │ 4. Подписка через PushManager
       ▼
┌─────────────────┐
│  Service Worker │
└──────┬──────────┘
       │
       │ 5. Создание подписки
       ▼
┌─────────────────┐
│ Push-сервис     │
│ (FCM/Firefox)   │
└─────────────────┘
       │
       │ 6. Сохранение подписки
       ▼
┌─────────────────┐         ┌──────────────┐
│   Бэкенд        │────────►│  База данных │
│   (FastAPI)     │         │  (Supabase)  │
└─────────────────┘         └──────────────┘

═══════════════════════════════════════════════

Когда нужно отправить уведомление:

┌─────────────────┐
│   Бэкенд        │
│   (FastAPI)     │
└──────┬──────────┘
       │
       │ 1. Получение подписок из БД
       ▼
┌──────────────┐
│ База данных  │
│ (Supabase)   │
└──────┬───────┘
       │
       │ 2. Для каждой подписки:
       ▼
┌─────────────────┐
│   Бэкенд        │
│   (pywebpush)   │
└──────┬──────────┘
       │
       │ 3. Шифрование и отправка
       ▼
┌─────────────────┐
│ Push-сервис     │
│ (FCM/Firefox)   │
└──────┬──────────┘
       │
       │ 4. Доставка на устройство
       ▼
┌─────────────────┐
│  Service Worker │
└──────┬──────────┘
       │
       │ 5. Расшифровка и показ
       ▼
┌─────────────┐
│ Пользователь │
└─────────────┘
```

---

## Безопасность

### Защита паролей

- Пароли никогда не хранятся в открытом виде
- Используется bcrypt для хеширования
- При проверке пароль сравнивается с хешем

### Защита API

- Все защищенные эндпоинты требуют JWT токен
- Токены имеют срок действия (30 дней)
- Токены подписываются секретным ключом

### Защита подписок

- Каждая подписка связана с пользователем
- Пользователь может отправлять уведомления только себе
- Подписки шифруются с помощью ключей `p256dh` и `auth`

### VAPID аутентификация

- Приватный VAPID ключ хранится только на сервере
- Публичный ключ используется для подписки
- Push-сервисы проверяют подпись перед доставкой

---

## Технические детали

### Что такое Service Worker?

- JavaScript файл, который работает в фоне браузера
- Может работать даже когда сайт закрыт
- Обрабатывает push-события и показывает уведомления
- Имеет доступ к кэшу для офлайн-работы

### Что такое Web Push API?

- Стандарт W3C для отправки push-уведомлений
- Работает через push-сервисы браузеров (FCM, Firefox Push Service)
- Использует шифрование для безопасности
- Поддерживается в современных браузерах

### Что такое VAPID?

- Протокол для идентификации сервера при отправке push-уведомлений
- Позволяет не использовать сторонние сервисы
- Состоит из пары ключей (публичный/приватный)
- Приватный ключ используется для подписи запросов

### Что такое JWT?

- JSON Web Token - стандарт для передачи информации
- Состоит из трех частей: заголовок, данные, подпись
- Подпись гарантирует, что токен не был изменен
- Используется для авторизации без хранения сессий на сервере

---

## Возможные проблемы и решения

### Уведомления не приходят

1. Проверьте разрешение на уведомления в браузере
2. Убедитесь, что Service Worker зарегистрирован
3. Проверьте консоль браузера на ошибки
4. Убедитесь, что VAPID ключи настроены правильно

### Подписка не сохраняется

1. Проверьте токен авторизации
2. Убедитесь, что база данных доступна
3. Проверьте логи бэкенда

### Ошибки при отправке уведомлений

1. Проверьте валидность подписок в базе данных
2. Убедитесь, что VAPID приватный ключ настроен
3. Проверьте формат данных уведомления

---

## Заключение

Это приложение демонстрирует полный цикл работы с push-уведомлениями:

1. Авторизация пользователей
2. Подписка на уведомления
3. Сохранение подписок
4. Отправка уведомлений
5. Доставка и отображение уведомлений

Все компоненты работают вместе, обеспечивая безопасную и надежную доставку push-уведомлений пользователям.
